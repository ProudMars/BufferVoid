{"version":3,"sources":["../src/dom.ts","../src/utils/stream-loader.ts","../src/player.ts","../src/utils/helpers.ts","../src/buffer-void.ts"],"sourcesContent":["export function getAttribute(elm: Element, attr: string) {\n    return elm.getAttribute(attr)\n}\n\nexport function getAttributes(elm: Element) {\n    return elm.attributes\n}\n\nexport function setAttribute(elm: Element, attr: string, val: string | boolean) {\n    if (typeof val == \"string\") {\n        elm.setAttribute(attr, val)\n    } else {\n        elm.setAttribute(attr, val + \"\")\n    }\n}\n\nexport function querySelector(selector: string) {\n    return document.querySelector(selector)\n}\n\nexport function replaceWith(elm: Element, ...replaceNode: (Node | string)[]) {\n    return elm.replaceWith(...replaceNode)\n}\n\nexport function createElement<T extends keyof HTMLElementTagNameMap>(\n    tagName: T,\n    options?: ElementCreationOptions\n): HTMLElementTagNameMap[T] {\n    return document.createElement<T>(tagName, options)\n}","/**\n * StreamLoader - Handles fetching video chunks and feeding them to MediaSource\n * Uses Fetch API and Media Source Extensions (MSE) to stream video content\n */\n\nexport interface StreamLoaderOptions {\n  chunkSize: number;  // Size of each chunk in bytes\n  bufferAhead: number; // Number of chunks to buffer ahead\n  initialBufferSize: number; // Initial buffer size in chunks\n  mimeType: string; // MIME type of the video (e.g., 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"')\n}\n\nexport default class StreamLoader {\n  private mediaSource: MediaSource;\n  private sourceBuffer: SourceBuffer | null = null;\n  private videoElement: HTMLVideoElement;\n  private videoUrl: string;\n  private options: StreamLoaderOptions;\n  private abortController: AbortController | null = null;\n  private isLoading: boolean = false;\n  private isBuffering: boolean = false;\n  private currentChunk: number = 0;\n  private totalChunks: number = 0;\n  private contentLength: number = 0;\n  private loadedChunks: Set<number> = new Set();\n  private pendingChunks: Set<number> = new Set();\n\n  // Default options\n  private static defaultOptions: StreamLoaderOptions = {\n    chunkSize: 1024 * 1024, // 1MB chunks\n    bufferAhead: 3, // Buffer 3 chunks ahead\n    initialBufferSize: 2, // Initially load 2 chunks\n    mimeType: 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"'\n  };\n\n  constructor(videoElement: HTMLVideoElement, videoUrl: string, options?: Partial<StreamLoaderOptions>) {\n    this.videoElement = videoElement;\n    this.videoUrl = videoUrl;\n    this.options = { ...StreamLoader.defaultOptions, ...options };\n    this.mediaSource = new MediaSource();\n    \n    // Set up MediaSource\n    this.videoElement.src = URL.createObjectURL(this.mediaSource);\n    \n    this.mediaSource.addEventListener('sourceopen', this.onSourceOpen.bind(this));\n    this.mediaSource.addEventListener('sourceended', () => console.log('MediaSource ended'));\n    this.mediaSource.addEventListener('sourceclose', () => console.log('MediaSource closed'));\n    \n    // Set up video element event listeners\n    this.videoElement.addEventListener('seeking', this.onSeeking.bind(this));\n    this.videoElement.addEventListener('waiting', this.onBuffering.bind(this));\n    this.videoElement.addEventListener('playing', this.onPlaying.bind(this));\n  }\n\n  /**\n   * Initialize the stream loader and start loading initial chunks\n   */\n  public async initialize(): Promise<void> {\n    try {\n      // Get content length to calculate total chunks\n      const response = await fetch(this.videoUrl, { method: 'HEAD' });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch video info: ${response.status} ${response.statusText}`);\n      }\n      \n      const contentLength = response.headers.get('content-length');\n      if (!contentLength) {\n        throw new Error('Content length not available');\n      }\n      \n      this.contentLength = parseInt(contentLength, 10);\n      this.totalChunks = Math.ceil(this.contentLength / this.options.chunkSize);\n      \n      console.log(`Video size: ${this.contentLength} bytes, Total chunks: ${this.totalChunks}`);\n      \n      // Load initial chunks\n      for (let i = 0; i < this.options.initialBufferSize && i < this.totalChunks; i++) {\n        this.loadChunk(i);\n      }\n    } catch (error) {\n      console.error('Error initializing stream loader:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Handle MediaSource open event\n   */\n  private onSourceOpen(): void {\n    console.log('MediaSource opened');\n    \n    try {\n      // Create source buffer\n      this.sourceBuffer = this.mediaSource.addSourceBuffer(this.options.mimeType);\n      \n      // Set up source buffer event listeners\n      this.sourceBuffer.addEventListener('updateend', this.onSourceBufferUpdateEnd.bind(this));\n      this.sourceBuffer.addEventListener('error', (e) => console.error('SourceBuffer error:', e));\n      \n      // Set mode to segments for better seeking\n      this.sourceBuffer.mode = 'segments';\n    } catch (error) {\n      console.error('Error setting up source buffer:', error);\n    }\n  }\n\n  /**\n   * Handle source buffer update end event\n   */\n  private onSourceBufferUpdateEnd(): void {\n    if (!this.sourceBuffer) return;\n    \n    // If we're not at the end and not currently loading, load more chunks\n    if (this.currentChunk < this.totalChunks - 1 && !this.isLoading) {\n      this.loadNextChunks();\n    }\n    \n    // If we've loaded all chunks, close the media source\n    if (this.loadedChunks.size === this.totalChunks && !this.sourceBuffer.updating) {\n      try {\n        this.mediaSource.endOfStream();\n      } catch (error) {\n        console.error('Error ending media source stream:', error);\n      }\n    }\n  }\n\n  /**\n   * Handle video seeking event\n   */\n  private onSeeking(): void {\n    if (!this.sourceBuffer || !this.videoElement) return;\n    \n    const currentTime = this.videoElement.currentTime;\n    const buffered = this.sourceBuffer.buffered;\n    \n    // Check if the seek position is already buffered\n    let isBuffered = false;\n    for (let i = 0; i < buffered.length; i++) {\n      if (currentTime >= buffered.start(i) && currentTime <= buffered.end(i)) {\n        isBuffered = true;\n        break;\n      }\n    }\n    \n    // If not buffered, load the appropriate chunk\n    if (!isBuffered) {\n      // Calculate which chunk contains the seek position\n      const seekPositionRatio = currentTime / this.videoElement.duration;\n      const estimatedChunk = Math.floor(seekPositionRatio * this.totalChunks);\n      \n      console.log(`Seeking to time ${currentTime}, loading chunk ${estimatedChunk}`);\n      \n      // Cancel current loads\n      this.abortCurrentLoads();\n      \n      // Clear pending chunks\n      this.pendingChunks.clear();\n      \n      // Load the chunk for the seek position and subsequent chunks\n      for (let i = estimatedChunk; i < estimatedChunk + this.options.bufferAhead && i < this.totalChunks; i++) {\n        if (!this.loadedChunks.has(i)) {\n          this.loadChunk(i);\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle video buffering event\n   */\n  private onBuffering(): void {\n    this.isBuffering = true;\n    console.log('Video is buffering');\n    \n    // Increase buffer ahead when buffering\n    const tempBufferAhead = this.options.bufferAhead * 2;\n    \n    // Load more chunks ahead\n    for (let i = this.currentChunk + 1; i < this.currentChunk + tempBufferAhead && i < this.totalChunks; i++) {\n      if (!this.loadedChunks.has(i) && !this.pendingChunks.has(i)) {\n        this.loadChunk(i);\n      }\n    }\n  }\n\n  /**\n   * Handle video playing event\n   */\n  private onPlaying(): void {\n    this.isBuffering = false;\n    console.log('Video is playing');\n  }\n\n  /**\n   * Load the next set of chunks based on buffer ahead setting\n   */\n  private loadNextChunks(): void {\n    const nextChunk = this.currentChunk + 1;\n    \n    for (let i = nextChunk; i < nextChunk + this.options.bufferAhead && i < this.totalChunks; i++) {\n      if (!this.loadedChunks.has(i) && !this.pendingChunks.has(i)) {\n        this.loadChunk(i);\n      }\n    }\n  }\n\n  /**\n   * Load a specific chunk\n   */\n  private async loadChunk(chunkIndex: number): Promise<void> {\n    if (this.loadedChunks.has(chunkIndex) || this.pendingChunks.has(chunkIndex)) {\n      return;\n    }\n    \n    this.pendingChunks.add(chunkIndex);\n    this.isLoading = true;\n    \n    const start = chunkIndex * this.options.chunkSize;\n    const end = Math.min(start + this.options.chunkSize - 1, this.contentLength - 1);\n    \n    console.log(`Loading chunk ${chunkIndex} (bytes ${start}-${end})`);\n    \n    this.abortController = new AbortController();\n    \n    try {\n      const response = await fetch(this.videoUrl, {\n        headers: {\n          Range: `bytes=${start}-${end}`\n        },\n        signal: this.abortController.signal\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch chunk ${chunkIndex}: ${response.status} ${response.statusText}`);\n      }\n      \n      const data = await response.arrayBuffer();\n      \n      // Append the chunk to the source buffer if it's ready\n      if (this.sourceBuffer && !this.sourceBuffer.updating) {\n        this.sourceBuffer.appendBuffer(data);\n        this.loadedChunks.add(chunkIndex);\n        this.currentChunk = Math.max(this.currentChunk, chunkIndex);\n        console.log(`Chunk ${chunkIndex} loaded and appended`);\n        \n        // Dispatch custom event for UI updates\n        this.dispatchChunkLoadedEvent();\n      } else {\n        // If source buffer is busy, wait and try again\n        console.log(`Source buffer busy, queuing chunk ${chunkIndex}`);\n        setTimeout(() => {\n          if (this.sourceBuffer && !this.sourceBuffer.updating) {\n            try {\n              this.sourceBuffer.appendBuffer(data);\n              this.loadedChunks.add(chunkIndex);\n              this.currentChunk = Math.max(this.currentChunk, chunkIndex);\n              console.log(`Chunk ${chunkIndex} loaded and appended (delayed)`);\n              \n              // Dispatch custom event for UI updates\n              this.dispatchChunkLoadedEvent();\n            } catch (error) {\n              console.error(`Error appending delayed chunk ${chunkIndex}:`, error);\n            }\n          }\n        }, 100);\n      }\n    } catch (error: unknown) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        console.log(`Loading of chunk ${chunkIndex} aborted`);\n      } else {\n        console.error(`Error loading chunk ${chunkIndex}:`, error);\n      }\n    } finally {\n      this.pendingChunks.delete(chunkIndex);\n      this.abortController = null;\n      this.isLoading = false;\n      \n      // Check if we need to load more chunks\n      if (this.pendingChunks.size === 0 && !this.isBuffering) {\n        this.loadNextChunks();\n      }\n    }\n  }\n\n  /**\n   * Abort current chunk loads\n   */\n  private abortCurrentLoads(): void {\n    if (this.abortController) {\n      this.abortController.abort();\n      this.abortController = null;\n    }\n    this.isLoading = false;\n  }\n\n  /**\n   * Dispatch a custom event with chunk loading information\n   * This is used to update the UI with loading progress\n   */\n  private dispatchChunkLoadedEvent(): void {\n    // Create and dispatch a custom event with chunk loading details\n    const event = new CustomEvent('chunkLoaded', {\n      detail: {\n        loadedChunks: this.loadedChunks.size,\n        totalChunks: this.totalChunks,\n        currentChunk: this.currentChunk,\n        isBuffering: this.isBuffering\n      }\n    });\n    \n    // Dispatch the event on the window object so it can be caught by the UI\n    window.dispatchEvent(event);\n  }\n\n  /**\n   * Clean up resources\n   */\n  public dispose(): void {\n    this.abortCurrentLoads();\n    \n    // Remove event listeners\n    this.videoElement.removeEventListener('seeking', this.onSeeking.bind(this));\n    this.videoElement.removeEventListener('waiting', this.onBuffering.bind(this));\n    this.videoElement.removeEventListener('playing', this.onPlaying.bind(this));\n    \n    if (this.sourceBuffer) {\n      this.sourceBuffer.removeEventListener('updateend', this.onSourceBufferUpdateEnd.bind(this));\n    }\n    \n    // Clear references\n    this.sourceBuffer = null;\n    this.loadedChunks.clear();\n    this.pendingChunks.clear();\n  }\n}\n","import { createElement, replaceWith } from \"./dom\";\nimport { VideoElemOptions } from \"./buffer-void\";\nimport StreamLoader, { StreamLoaderOptions } from \"./utils/stream-loader\";\n\nexport interface PlayerOptions extends VideoElemOptions {\n  useChunkedLoading?: boolean;\n  streamOptions?: Partial<StreamLoaderOptions>;\n}\n\nclass Player {\n    videoElm: HTMLVideoElement | undefined;\n    elm: HTMLElement;\n    options: PlayerOptions;\n    #controls: boolean;\n    #streamLoader: StreamLoader | undefined;\n    \n    static players: { [key: string]: Player } = {};\n\n    constructor(elm: HTMLElement, options: PlayerOptions = {}) {\n        elm.id = elm.id || `buffer-void-${parseInt(elm.id) + 1}`;\n\n        this.#controls = !!options.controls;\n        delete options.controls;\n\n        this.options = options;\n        this.elm = elm;\n\n        this.createPlayer();\n\n        Player.players[elm.id] = this;\n        \n        // Initialize stream loader if chunked loading is enabled\n        if (this.options.useChunkedLoading && this.videoElm && this.options.src) {\n            this.initializeStreamLoader();\n        }\n    }\n\n    play() {\n        if (this.videoElm) {\n            this.videoElm.play();\n        }\n    }\n\n    pause() {\n        if (this.videoElm) {\n            this.videoElm.pause();\n        }\n    }\n\n    autoPlay() {\n        if (this.videoElm) {\n            this.videoElm.muted = true;\n            this.videoElm.play();\n        }\n    }\n\n    muted(val: boolean) {\n        if (this.videoElm) {\n            this.videoElm.muted = val;\n        }\n    }\n\n    createPlayer() {\n        const videoElm = createElement('video');\n\n        // If we're using chunked loading, don't set the src attribute directly\n        const skipSrcAttribute = this.options.useChunkedLoading;\n        \n        for (let option in this.options) {\n            // Skip non-attribute options\n            if (option === 'useChunkedLoading' || option === 'streamOptions') {\n                continue;\n            }\n            \n            // Skip src if using chunked loading\n            if (skipSrcAttribute && option === 'src') {\n                continue;\n            }\n            \n            videoElm.setAttribute(option, this.options[option as keyof VideoElemOptions] as string);\n        }\n\n        if (this.options.width) {\n            this.elm.style.width = this.options.width + \"px\";\n        }\n        \n        if (this.options.height) {\n            this.elm.style.height = this.options.height + \"px\";\n        }\n\n        this.elm.prepend(videoElm);\n        this.videoElm = videoElm;\n    }\n\n    /**\n     * Initialize the stream loader for chunked video loading\n     */\n    private initializeStreamLoader() {\n        if (!this.videoElm || !this.options.src) {\n            console.error('Cannot initialize stream loader: video element or source URL is missing');\n            return;\n        }\n        \n        try {\n            // Create and initialize the stream loader\n            this.#streamLoader = new StreamLoader(\n                this.videoElm,\n                this.options.src,\n                this.options.streamOptions\n            );\n            \n            // Initialize the stream loader\n            this.#streamLoader.initialize().catch(error => {\n                console.error('Failed to initialize stream loader:', error);\n                \n                // Fallback to regular video loading if streaming fails\n                if (this.videoElm && this.options.src) {\n                    console.log('Falling back to regular video loading');\n                    this.videoElm.src = this.options.src;\n                }\n            });\n            \n            console.log('Chunked video loading initialized');\n        } catch (error) {\n            console.error('Error setting up chunked video loading:', error);\n            \n            // Fallback to regular video loading\n            if (this.videoElm && this.options.src) {\n                this.videoElm.src = this.options.src;\n            }\n        }\n    }\n\n    /**\n     * Clean up resources when the player is destroyed\n     */\n    dispose() {\n        // Clean up stream loader if it exists\n        if (this.#streamLoader) {\n            this.#streamLoader.dispose();\n            this.#streamLoader = undefined;\n        }\n        \n        // Remove the player from the static players object\n        if (this.elm.id && Player.players[this.elm.id]) {\n            delete Player.players[this.elm.id];\n        }\n    }\n\n    createControls() {\n        const div = document.createElement('div');\n        // Control implementation would go here\n    }\n}\n\nexport default Player;\n","export function normalizeId(id: string) {\n    return id.startsWith('#') ? id.slice(1) : id\n}","import { querySelector } from \"./dom\";\nimport Player, { PlayerOptions } from \"./player\";\nimport { normalizeId } from \"./utils/helpers\";\n\nexport interface VideoElemOptions {\n    controls?: boolean;\n    muted?: boolean;\n    autoplay?: boolean;\n    controlslist?: 'nodownload' | 'nofullscreen' | 'noremoteplaybac';\n    crossorigin?: 'anonymous' | 'use-credentials';\n    disablepictureinpicture?: boolean;\n    disableremoteplayback?: boolean;\n    height?: number;\n    width?: number;\n    loop?: boolean;\n    playsinline?: boolean;\n    poster?: string;\n    preload?: 'none' | 'metadata' | 'auto';\n    src?: string;\n}\n\nclass BufferVoid {\n    static playerId: string | undefined;\n    static player: Player | undefined;\n    \n    /**\n     * Create a new BufferVoid video player instance\n     * \n     * @param id - The ID of the element to attach the player to\n     * @param options - Configuration options for the player\n     */\n    constructor(id: string, options: PlayerOptions = {}) {\n        // Check if we already have a player instance\n        let player = this.getPlayer();\n\n        if (player) {\n            if (options && Object.keys(options).length > 0) {\n                console.warn(\"Options will not apply, player is already instantiated!\");\n            }\n\n            BufferVoid.playerId = id;\n            BufferVoid.player = player;\n        } else {\n            // Find the element by ID\n            const elm = querySelector(`#${normalizeId(id)}`);\n            if (!elm) {\n                throw new Error(\"Invalid ElementID passed\");\n            }\n            \n            if (!(elm instanceof HTMLElement)) {\n                throw new Error(\"Element is not an HTMLElement\");\n            }\n\n            // Create a new player instance\n            BufferVoid.player = new Player(elm, options);\n            BufferVoid.playerId = id;\n        }\n    }\n\n    /**\n     * Get the current player instance if it exists\n     */\n    getPlayer() {\n        if (BufferVoid.playerId) {\n            const player = Player.players[BufferVoid.playerId];\n            if (player) {\n                return player;\n            }\n        }\n        return undefined;\n    }\n    \n    /**\n     * Create a player with chunked loading enabled\n     * \n     * @param id - The ID of the element to attach the player to\n     * @param src - The source URL of the video\n     * @param options - Additional player options\n     */\n    static createStreamingPlayer(id: string, src: string, options: Partial<PlayerOptions> = {}) {\n        const streamingOptions: PlayerOptions = {\n            ...options,\n            src,\n            useChunkedLoading: true,\n            streamOptions: {\n                chunkSize: options.streamOptions?.chunkSize || 1024 * 1024, // Default 1MB chunks\n                bufferAhead: options.streamOptions?.bufferAhead || 3,\n                initialBufferSize: options.streamOptions?.initialBufferSize || 2,\n                mimeType: options.streamOptions?.mimeType || 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"'\n            }\n        };\n        \n        return new BufferVoid(id, streamingOptions);\n    }\n    \n    /**\n     * Clean up resources when the player is no longer needed\n     */\n    dispose() {\n        if (BufferVoid.player) {\n            BufferVoid.player.dispose();\n            BufferVoid.player = undefined;\n            BufferVoid.playerId = undefined;\n        }\n    }\n}\n\nexport default BufferVoid;\n"],"mappings":"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","names":[]}